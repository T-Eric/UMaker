# UMaker - 做一个 CPU

本人很懒。推己及人，本人也一点不希望麻烦别人。😴

诶☝️🤓，本着“玩游戏一定不是一件麻烦事”的奇怪信念，鄙人向大家推荐游戏 [Turing Complete](https://store.steampowered.com/app/1444480/Turing_Complete/)！只要把这个游戏通关，你就做出了一台属于自己的电脑，你对于计算机体系结构的理解也将得到认可！

但是这个游戏在 Steam 上要 70 块大洋……而目前市面上的枪版都是游戏的早期版本，存在一个阻碍推关的恶性 bug。十分可惜，只能用别的软件复现这个项目了……这既意味着，富有特色的功能（如 4k 液晶大屏，实时数据流等）都不存在了，也意味着 baseline 的要求是低于将原游戏通关的！（同时更意味着更方便团体协作，以及设计一些高于原游戏功能的 bonus）

就这么决定了，这个项目希望大家从零开始制作一个16位的CPU，并用它写代码跑程序！

## Baseline

讲解环节。16 位 CPU 的概念大家可以自行 google ，简单说就是 CPU 一次操作可以处理 16 bit 的数据，代码层面一般体现为处理一条 16 bit 长的汇编代码。

Baseline的目标便是，在一个逻辑电路模拟器软件中，像搭积木一样拼出一个可以运行汇编程序的 CPU。软件可以从我已知的三个中选一个下载，也可以自选（能向助教推荐就更好了）：

- [LogicCircuit](https://www.logiccircuit.org/)
- [Logisim](https://github.com/SecondCat/Logisim-Translation-Chinese/releases)
- [Digital](https://blog.csdn.net/TENET123/article/details/139721720)

上述软件本质并无太大区别，大家按自己试手手感和 UI 偏好选个即可。LogicCircuit 的功能和 UI 都比较老，后两个需要先装 java。

一般软件中，左侧列表的基本元件都可以使用（也就是说，你不需要写1024个锁存器来储存1kb数据，直接用 RAM 即可）。但是要使用更复杂的元件，则需要自己构造。

当然，做图形化模拟主要是考虑到各位的代码熟练度可能不够，并不想给各位增加太多学习成本和压力；何况我也希望这个项目真的成为轻松的“游戏”。若有强者，可以考虑直接学习 **Verilog 语言**！用它实现一整个 CPU，甚至可以直接把 Bonus 做完，分数圆满！

既然我都这么说了，由于我比较懒，恕不在此提供具体配环境方法和教程链接，恕罪恕罪。

------

首先，我们的实现基于时序逻辑的原理，请先学习之。与之相对的概念是组合逻辑，请自行查阅。

简单说，我们搭的许多逻辑门电路组合，输入什么立刻得到什么，是组合逻辑。但是一个程序运行时，下一串代码得到的输出很可能与上一串代码带来的输入有关；CPU 也是，为了实现高自由度的功能，这一刻的输出最好根据前一刻带来的输入而产生变化，则是时序逻辑。

- [Sequential logic - Wikipedia](https://en.wikipedia.org/wiki/Sequential_logic)
- [Combinational logic - Wikipedia](https://en.wikipedia.org/wiki/Combinational_logic)

然后，请来了解一下 CPU 的组成，了解自己要做几大块元件。概括地说，我们要了解并做这些：

- 运算器，负责算术和逻辑运算。具体说，你要做一块 ALU 做一元和二元四则运算（输出16位答案）和一块判断单元（用于做诸如大于0等比较，输出1位答案），然后把它们跟一些暂存数据的寄存器（理论上至少 3 个）连在一起。
- 寄存器，负责存储。RAM 也算寄存器大类。
- 控制器，负责控制整个 CPU 运作，包括：
  - 指令翻译器（ID, instruction decoder）将指令中的每个有效 bit 对应为你需要的输入。
  - 程序计数器（PC, program counter），指出下一条要执行的指令的位置。如果用一块 ROM 储存一个程序，则输入 PC 的值应当得到当前要执行的指令代码。
  - 时序产生器（CLK，clock），是时序逻辑电路的核心部件，所以理论上左边工具栏已经给出。

再然后，说一下指令集和程序这一部分。

指令，就是用自己每一位的值告诉程序该做什么。你可以自由设定自己的指令有多少位，但是记住数字是16位的。一种通过立即数赋值的指令可以实现为，最高位的 0 和 1 代表这条指令是个值还是个指令，如果是个值，就把它直接塞入某个寄存器中，否则交给 ID 翻译为具体要做的事。

各位需要自己拟定一套指令集，并把对应功能实现到你的运算器、控制器里。我会给出一些简单的 c++ 代码，请各位用自己设计的指令翻译之，再将指令转化为机器码注入一块 ROM 中供 PC 读取。

指令集设计可以参考 riscv32 标准下的指令集（一种 RISC 指令集）。为什么呢？不仅是因为他们的指令集备受认可、十分科学，更是因为你能直接将 c++ 代码编译为 riscv32 代码，你可以直观观察这个转换逻辑并直接模仿。这一步的更详细教程放在 `compile_helper.md` 中。

上述教程已能助你通关baseline。更多功能和更详细的介绍，请参见软件官网的帮助文档。

提醒！要拿满分 Bonus 是必须要选来做的，有些 bonus 会要求你做出一个 32 位的CPU，以实现特定功能（变量不变质的工作，欢迎直接做 32 位），或者有一些优化工作最好在 baseline 阶段就做下铺垫。故，先去 bonus 环节看看比较好。

------

如果觉得不够直观，或者手痒希望从实战中学习，抑或只是想为届不到的 Turing Complete 游戏找个代餐玩玩，都向各位推荐网站 [NandGame](https://www.nandgame.com/)！这实际上也是我向大家推出的教程之一，完全按照这个来做，尽管与实际上的现代 CPU 有所区别，但是能实现完整的功能！

自其关卡设计便可得知 baseline 的所有步骤，跟着玩一遍便能掌握 baseline 的一切要领，任务几乎变为只用在 LogicCircuit 软件上进行机械复现。推荐玩完 HardWare 和 SoftWare 两部分，都十分有趣，但是 HardWare 部分已然覆盖了 baseline 的全部内容。

是不是很轮椅？♿♿♿欢迎挑战最少元件解法！

## 规则与提示

规则会用粗体标出，提示自己领悟。规则省流版：

1. 如果要做独立寄存器，不能拥有超过 16 个寄存器，不限制最少寄存器数。0 号寄存器请设计为会在任意 CPU 时刻都强制保持值为 0 的状态（如果不编号，那就是有一个寄存器保持其值为 0）。寄存器可以是任意位大小的，只要你觉得可以完成任务。

2. 必须实现的汇编功能（指令）还是去看看详细版为好 :P。指令加了括号，是因为不限制指令的实现方式，也就不限制完成 baseline 任务的实现方式，也意味着你需要自己设计指令集。

详细版：

- 如果你不打算做任何 ALU 和 RAM 外的独立寄存器，请忽略这一条。

  寄存器是很重要的元件。汇编环节不得不用寄存器，即使你只用寄存器来运算，而一般时候把数据存在内存里。

  一台计算机的寄存器数量有限，且部分寄存器有一些约定俗成的功能和使用规则。我们不管那些，只是**规定不能拥有超过 16 个独立寄存器，而且 0 号寄存器需要时刻强制把自己的值设置为 0**。

  拓展：在精简指令集（RISC）中，许多不太底层但是更常用的操作无法直接占用宝贵的指令集空间，因此一个值永远为 0 的寄存器 `x0` 十分方便。比如，riscv指令集中的伪指令 `mv rd, rs`，即 move，将一个寄存器的值复制到另一个寄存器，其可以由 `add rd, rs, x0`简便实现；`li rd, imm`，即 load immediate，将一个立即数直接存进寄存器，被实现为 `addi rd, x0, imm`。

- 指令集会告诉ALU做什么运算，你需要用数个bit的指令码opcode来“激活”ALU中的某个运算功能。**以下功能是必须要设计的，具体细节你可以自由实现**。后面的汇编环节中，你大概率会用到他们。

  - `ADD x0, x1, x2`，即 `x0 = x1 + x2`。
  - `SUB`，用法同上。保证 baseline 阶段不需要支持答案为负数，但欢迎实现。
  - `SHL/SHR x0, x1, x2`，即 `x0=x1<<x2` 和 `x0=x1>>x2`，左移右移，丢失的位补0即可。
  - `JLE/JLT/JGE/JGT/JEZ/JNE/JMP`，分别是不大于0/小于0/不小于0/大于0/等于0/不等于0/无条件跳转。用于判断的寄存器自定，可以单独设计一个，也可以是其他元件中的寄存器，主要是为了实现指令跳转功能。
  - 取地址的方法。向 RAM 和 ROM 中输入地址得到对应地址存储的值的功能。

  其余的指令，方便的，秀的，都可以随便设计。但是需要注意，我们的CPU是16位的，你要仔细考虑如何用一条指令 16 bit 的容量装下至少一个操作数、一个目标寄存器编号、若干个其他寄存器编号，或者若干数字。

- 小技巧：ROM 地址映射，作常量数组使用。对其输入一个地址，输出这个地址存储的值。

  一个用例：一般我们需要用 7-seg 晶体管来显示数字（也推荐这么做），本质是从单个十六进制数字到一串 8 bit 码，控制晶体管上哪个灯亮。如同 `int months[12]={31,28,31,...}` ，这不正是常量数组吗？直接把每个数字对应的亮灯方式写进 ROM 即可完成转换。

  大家**随便用**。从贴合现实的角度，不推荐用太多，因为 CPU 和 ROM 是分离的，ROM 的大小和数量在实际计算机中都有限。

- **重要！**务必关注边界情况和未定义情况！

  比如 LogicalCircuit程序中，如果一个二元逻辑门有且只有一端没有接输入，那么这个元件会变成一根导线（可以拿 `and` 门一试），而不会有任何提示。连锁反应之后可能造成不可预料的后果。因此**请确保最终 CPU 中不存在没有输入的输入口！**

  其他程序，请使用者自行测试相关特性，后期再修可能会十分麻烦。。。

## Bonus

不够，不够，不够！

给大家一点玩的方向。大家可以任意点一些tag去做，完成后按照要求向我们展示你做完了、做到了，即可。

### 优化

这一部分的“成果要求”比较抽象，不喜轻喷。欢迎私信助教提出对“成果要求”的修改意见。

- 精简元件。

  如果已经玩过 NandGame，你会发现它每一关都会统计你所用的元件数和对应的（所有元件最少与非门下）的 `nand` 使用数。如果选择这条 bonus，默认你玩通了 NandGame 的前五个章节。

  那么首先，请尝试：**在 NandGame 的前五个章节的每一关中，做到使用最少 `nand` 使用数的成就，全屏截图保存每关的通关记录和你的实现**。

  接着，请算出：**在你的 CPU 工程中，将所有元件替换为 `nand` 门实现（不包括三态门），总共用了多少 `nand`？在你的报告中写出你的统计方式和最终数据**。

  注意，寄存器其实不需要三态门就可以做出来，这取决于你的实现方式。也因此，整个工程都可以不需要三态门，但是弄懂三态门会对你的工程大有帮助。

  拓展：重视 `nand`，这是因为 `nand` 和 `nor` 各自可以做成其他所有逻辑门（[Universal Gate: NAND and NOR Gate as Universal Gates](https://www.electrical4u.com/universal-gate-nand-nor-gate-as-universal-gate/)），**除了三态门**。同时，与非门在实际生产中优于或非门（[Why is NAND gate preferred over NOR gate in industry?](https://electronics.stackexchange.com/questions/110649/why-is-nand-gate-preferred-over-nor-gate-in-industry)）。

### 功能

- 简单功能补全。

  - 支持有符号整数。包括 16 位有符号整数运算和带负号的 LED 显示。

  - 支持外界输入数字。大致实现思路是，CPU 运行时，可在 RAM 的固定地址处写入值（模拟控制台输入），然后在另一个固定地址改变一次值作为输入完毕的信号（模拟按下回车结束输入）。你可以添加新的指令（其实可以不用）来控制读入。

    在等待输入时 CPU 仍在运作，输入完毕之前会过去许多 CPU 周期，需要好生考虑如何“等待”和“等到”。

  - 欢迎向助教提出你想要的实现！助教会根据实现的任务量和难度打分的！

- 浮点运算。

  这里的浮点数指采用 **IEEE 754** 标准的 **32** 位单精度浮点数。不需要处理 Nan 值、正负无穷这些特殊值，但是舍入标准等其他写明标准需要遵守并实现。当然，正负号也是需要考虑的，这意味着你得做出全新的ALU。

  拿满分数**只需要做出支持【精度达到小数点后三位的加减法】和【大于0和小于0的比较】的ALU（也就意味着你能做出浮点运算的CPU）**，没必要（但欢迎）考虑太多边界情况，如 UFL 和 OFL 溢出。直接在这个元件上运行，两个输入会逐 bit 转换为 32 bit Constant 元件的值后输入，但是**输出必须由 7-seg LED 灯组件进行直观显示**（这意味着你还需要动用那个小数点，并设计五位小数的显示方法）。

- 媒体播放器。这是一个纯堆量的可恨tag。

  用 LogicCircuit 的各位或许注意到左边有LED灯也有LED阵列，甚至有一个 Graphics Array 用于演示位图（尽管官方并未给出许多教程，在其他更先进的程序中实现这个应该容易得多）。我们希望即使不能用它直播《彩虹六号：围攻》，也一定可以播点图片或视频（虽然色调会很单）。故可以用一系列LED阵列拼成一块屏幕，通过程序控制其每个点的显示。

  **做到能演示 200×100 像素的图片可以拿一半分数**；**做出任意 20×10 像素的视频播放器，可以拿到全部分数**。具体实现方式随意，最终效果好看就行。

### 代码化

- 把 CPU 抽象为 Verilog 代码。

  这样做枯燥且麻烦，但是可以帮助你日后将CPU给“打印”出来，而且学一门新语言并非难事也并非无趣。

  由于学习量和工作量比较大，故**在 Verilog 中复现你的 ALU 即可得到全部分数**。其实做完这一步，由于 Verilog 的寄存器使用比较随意，你差不多可以复现整个CPU了。

### 创新

- 随意创新吧！可以根据我给出的几篇论文去做对应实现，也可以自选题材，恣意挥毫！虽然没有实际的任务要求和评分标准，但是如果能**在复现整个 NandGame 的过程中，就完成一些让自己都能眼前一亮的创新实现**，可以在你们的报告或者任意一个 md 文档中直接展示出来；或者，做出了工作量、先进程度达到上面 bonus 的完整任务，也是十分欢迎，向我们展示你的工作和示例（汇编程序，代码，电路项目等）即可！

  分数会根据你的实际工作量给分，当然也有随缘的成分。不过不必害怕！**在分数上为难大家绝对不是我的本意！**完整的、优秀的成果，我自会！

  选择此项，请务必提前私信助教，告知各位的实现细节，助教会酌情给出期望打分。

## 去做吧！

真乃十分简单，已然完全清晰。





## 轮椅中的轮椅

如果还是不得要领，那么隆重推荐，轮椅中的轮椅：

[[8位二进制CPU的设计和实现] CPU基本电路的实现](https://www.cnblogs.com/staraire/p/15311504.html)

[[8位二进制CPU的设计和实现] CPU微机架构的实现](https://www.cnblogs.com/staraire/p/15312822.html)

[[8位二进制CPU的设计和实现] CPU指令系统的实现](https://www.cnblogs.com/staraire/p/15312834.html)

这一套笔记从基本元件到程序设计，全部教会。各位当然可以顺藤摸瓜，去到B站上看大佬教程。不过这一套只能帮各位完成baseline就是了。

（由于这个教程存在，必须在baseline中就塞一些“改变”和“创新”啊……这是不是不太符合我“不麻烦”的原则？）
